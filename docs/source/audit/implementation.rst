Implementation notes
====================

.. contents:: Table of Contents
       :depth: 3

Abstract
========

This document provides basic information for backend developers regarding the
auditing implementation in TrueNAS.


Specification
=============

Storage and lifecycle management
--------------------------------
The auditing framework implementation is entirely governed by two middlewared
services:

*auditbackend* - this private service maintains connection to the auditing
sqlite3 databases and enforces audit record retention periods.

*audit* - this public service provides user-facing APIs that allow querying
audit records, exporting audit reports, and configuring audit dataset settings and retention period.

Developers must not write code interacting with the audit dataset or auditing
databases outside of the methods in these two plugins.

1. audit file storage location
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
TrueNAS audit information is written to per-service sqlite3 databases located
in a dedicated dataset boot device that is mounted at the path /audit. The
audit databases will be automatically created by middlewared or syslog-ng
(depending on the particular circumstances).

The permissions on the path `/audit` must be `0o700` and owned by root so as to
prevent unauthorized access to the audit files outside of the TrueNAS API.

2. audit file event insertion
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
All insertions into the auditing databases must be through the syslog-ng daemon.
This is to ensure that forwarding to remote destinations occurs.

3. audit file lifecycle management
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Retention period (*retention*) for audit records and quota / reservation
management for the audit dataset are managed by the API endpoints *audit.config*
and *audit.update*.

The retention period is enforced by a periodic middleware task
*auditbackend.__lifecycle_cleanup* that deletes all audit table entries with a
*message_timestamp* that is older than the configured retention period.

4. generating audit reports
^^^^^^^^^^^^^^^^^^^^^^^^^^^
API users may generate reports in various formats via the *audit.export* endpoint.

5. sending audit records to remote servers
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
If the server administrator has configured a remote syslog server in
*system.advanced* and has specified *syslog_audit* in the configuration, then
audit messages will be included in what is sent to the remote syslog server.

Adding new audited service to TrueNAS
-------------------------------------
The following procedure should be used to add a new audited service to the TrueNAS product

1. Expand list of AUDITED_SERVICES in `audit/utils.py`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The python list in `audit/utils.py` statically defines a list of services that
are audited on the TrueNAS server. Each list item is a tuple containing the
uppercase name of the service that is being audited and the version number of
the audited service. This should start at 0.1 and be incremented according to
versioning guidelines defined in internal design document NEP-041.

The service name serves as the basename for the sqlite3 database and so it must
be unique in the list, and the version identifier is used as part of the
automatically generated table name.

2. Add relevant readonly information to audit.config results
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
The *audit.config* API endpoint provides a basic configuration overview for
details of enabled services. For example, the SMB service provides a list of
names of shares for which auditing is enabled. This is somewhat free-form, but
the webui team should be consulted for feedback about what they want.

3. Determine contents of global svc_data for all audited events
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`svc_data` is free-form JSON data that the developer determines is relevant for
the audited service. Many audit events can have identical `svc_data`. A good rule
of thumb is to store session-specific information here. This may be None/NULL
if the developer determines it is unnecessary for the audited service.

4. Determine which events will be audited for the service and event_data for each of them
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Each audited event must have a unique (per-service) uppercase name. `event_data`
is free-form JSON data that the developer determines is relevant for the audited
event. This may be None/NULL if the developer determines it is unnecessary for
the audited service.

5. Write schemas for every event type that will be generated by service
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Write schema for the new service and add to the directory `plugins/audit/schema`.
The SMB service may be used as a guide for how to do this. NOTE: all audit
entries contain the same base keys as defined in the AuditEventParam enum in
`plugins/audit/schema/common.py` in accordance with previous NEP standards.

6. Expand the set of valid parameters to include the data from the new service schema
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
*audit.query* performs validation when the API user has specified `select`
query-options to ensure that the parameter being selected is actually provided
somewhere in our audit entries. This is to help users avoid generating malformed
audit information reports. The set of valid parameters must be expanded to
include the parameters from the new audited service.

7. Update the service to generate audit messages
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
7.1. Sending syslog message
The syslog-ng service filters audit messages based on the ident of the message
received so that they are inserted into the correct audit database. The service
in this case must set the ident to TNAUDIT_{service name}, for example `TNAUDIT_SMB`.

7.2. Audit message format
Audit entries are generated via specially crafted  syslog messages of the format:
`@cee:{"TNAUDIT": {<EVENT>}}`

Each audit event object must contain the following keys (as defined in NEP-041):


.. code-block:: text

    "aid" - audit identifier (GUID)
    "vers" - JSON object with major / minor versions
    "addr" - IP address of client (may be NULL)
    "sess" - GUID indicating session ID (may be NULL)
    "time" - ISO8601 timestamp of event (must not be NULL)
    "svc" - uppercase name of service being audited
    "svc_data" - see section 2.3 above (this should be JSON dumped)
    "event" - uppercase name of the event
    "event_data" - see section 2.4 above (this should be JSON dumped)
    "success" - boolean

7.3. Sample message:

.. code-block:: text

    @cee:{"TNAUDIT": {"aid": "5a1ad16d-7124-488d-8ec5-50e00fabc852", "vers": {"major": 0, "minor": 1}, "addr": "127.0.0.1", "user": "smbuser", "sess": null, "time": "2023-10-30 21:10:50.581658Z", "svc": "SMB", "svc_data": "{\"vers\": {\"major\": 0, \"minor\": 1}, \"service\": null, \"session_id\": null, \"tcon_id\": null}", "event": "AUTHENTICATION", "event_data": "{\"logonId\": \"0\", \"logonType\": 3, \"localAddress\": \"ipv4:127.0.0.1:445\", \"remoteAddress\": \"ipv4:127.0.0.1:48394\", \"serviceDescription\": \"SMB2\", \"authDescription\": null, \"clientDomain\": \"WORKGROUP\", \"clientAccount\": \"smbuser\", \"workstation\": \"TRUENAS\", \"becameAccount\": \"smbuser\", \"becameDomain\": \"TRUENAS\", \"becameSid\": \"S-1-5-21-2070160678-1985503795-992167086-20065\", \"mappedAccount\": \"smbuser\", \"mappedDomain\": \"WORKGROUP\", \"netlogonComputer\": null, \"netlogonTrustAccount\": null, \"netlogonNegotiateFlags\": \"0x00000000\", \"netlogonSecureChannelType\": 0, \"netlogonTrustAccountSid\": null, \"passwordType\": \"NTLMv2\", \"clientPolicyAccessCheck\": null, \"serverPolicyAccessCheck\": null, \"vers\": {\"major\": 0, \"minor\": 1}, \"result\": {\"type\": \"NTSTATUS\", \"value_raw\": 0, \"value_parsed\": \"SUCCESS\"}}", "success": true}}
